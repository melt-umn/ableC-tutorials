# Embedded Domain Specific Languages
A common pattern in writing extensions, in addition to basic new host-like constructs, is to define embedded domain specific languages (EDSLs) that are translated into the host language.  There are a number of applications of these, such as the expression of new types of computation (e.g. term rewriting), specifying transformations to perform on host code, or writting fragments of code in a subset of another language better suited for the task.  

The abstract and concrete syntax for an EDSL extension typically each introduce new nonterminals to represent the structure of the embedded language.  The new concrete syntax is rooted in a 'bridge production' from a host nonterminal, and uses the `ast` attribute to build the new abstract nonterminal.  The abstract syntax for the EDSL has a similar structure, with a bridge production (for ableC, usually on `Decl`, `Stmt` or `Expr`) that roots the syntax for the body of the EDSL.  Various attributes on the new abstract nonterminal are used to perform error-checking and compute the translation back into the host language, which are then used by the bridge production to either forward to an error production or to the resulting translation.  

## Expressions in ableC
For the following example, a quick introduction to how expressions work in ableC is needed.  The implementation of these may be found in the files [Expr.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/Expr.sv), [ExprUnaryOps.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/ExprUnaryOps.sv),  [ExprBinOps.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/ExprBinOps.sv), [ExprConstants.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/ExprConstants.sv) and [ExprBuiltins.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/ExprBuiltins.sv), with some additional supporting nonterminals and productions in [ExprContainers.sv](../../edu.umn.cs.melt.ableC/abstractsyntax/host/ExprContainers.sv).  The abstract syntax of an expression is represented by the `Expr` nonterminal, which has a mostly straightforward set of productions.  For example, `addEqExpr :: (Expr ::= Expr Expr)` performs a `+=` operation, or `memberExpr :: (Expr ::= Expr Boolean Name)` accesses an element from a struct, using the `.` or `->` operator.  

Some of the less-self-explanatory productions that may be useful are as follows:
* `stringLiteral :: (Expr ::= String)` is a string literal expression.  Note that the parameter literal string must include the enclosing quotes.  
* `directCallExpr :: (Expr ::= Name Exprs)` performs a function call where the function has a given name.  This usually resolves into `callExpr :: (Expr ::= Expr Exprs)`, but it also handles special compiler-specific builtin functions that don't act like ordinary functions when called.  
* `conditionalExpr :: (Expr ::= Expr Expr Expr)` is the `?:` ternary operator.
* `stmtExpr :: (Expr ::= Stmt Expr)` is the GCC extension statement-expression `({<Stmt>; <Expr>;})`, which allows for statments to be embedded inside of expressions.  This is highly useful for constructing forwards for extension `Expr` productions that require loops or temporary variables.  
* `sizeofExpr :: (Expr ::= ExprOrTypeName)` implements the `sizeof()`operator, and may be called on an `Expr` or `TypeName`, wrapped inside a `ExprOrTypeName` nonterminal.  
*TODO, this list is incomplete*

The concrete syntax of expressions follows an ETF-style grammar, with a nonterminal for every level of precedence and associative.  When introducing a new infix operator, a new production may be written for any one of these nonterminals to specify its precedence.  This does introduce some extra complexity, which can be sidestepped by writing expressions in prefix or postfix form.  

## Example
A simple example of an language that may be embedded in ableC is arithmetic expressions written in prefix form.  For this extension, we embed prefix expressions as a new variant of `Expr`, performing type checking with more specific error messages.  

In [ConcreteSyntax.sv](edu.umn.cs.melt.tutorials.ableC.prefixExpr/concretesyntax/ConcreteSyntax.sv), a new concrete nonterminal `PrefixExpr_c` is introduced.  Note that this nonterminal is marked `closed`: This means that other extensions extending this one may introduce new nonforwarding productions, but no new attributes, which makes sense in the context of concrete syntax.  Typically all abstract nonterminals are open and all concrete nonterminals are closed, but there are some exception to this.  

The productions on `PrefixExpr_c` specify the new concrete syntax of this EDSL.  Note that no new terminals are used here - it is preferable to make new concrete syntax resemble the host syntax when doing so is an option.  This helps to make the transition from host code to extension code as seamless as possible, and also aids in passing the modular analysis for concrete syntax, which will be described later.  

The last production on `PrefixExpr_c` is referred to an 'escape hatch' production, allowing a transition back from extension to host syntax.  This sort of production often requires special syntax, such as wrapping expressions in double-parentheses or statements in double-braces, to avoid syntactic ambiguities.  This workaround was not required for this particular example, since the EDSL syntax does not include parentheses.  

The abstract syntax for this extension can be found in [AbstractSyntax.sv](edu.umn.cs.melt.tutorials.ableC.prefixExpr/abstractsyntax/AbstractSyntax.sv).  Here the new `PrefixExpr` nonterminal represents the abstract structure of the EDSL.  This is rooted in the production `prefixExpr` bridging between host and extension abstract syntax, which simply checks for errors on the EDSL and forwards to an error production or the `toExpr` computed translation to host.  This translation is fairly simple in this case, but in more complex extensions may involve the use of numerous synthesized and inherited attributes to rebuild the AST, as for example in [the halide extension](https://github.com/melt-umn/ableC-halide)

Note that since `PrefixExpr` may contain `Expr`s, `PrefixExpr` must somehow provide all the inherited attributes needed by `Expr`.  Typically, most of these inherited attributes will occur on the new nonterminal, and simply be copied down from the top-level.  However, there are some cases where 'dummy' values may be provided for some inherited attributes (such as `returnType`) in cases where there is no actual value possible.  

[Next section: Construction helpers](../construction/)
